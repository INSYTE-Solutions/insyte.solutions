import React, { useEffect, useRef } from 'react';
import { gsap } from 'gsap';

const FlowingLinesAnimation: React.FC = () => {
  const svgRef = useRef<SVGSVGElement>(null);
  const numLines = 20;
  const amplitude = 50; // Max height of the wave
  const frequency = 0.02; // How many waves are visible
  const speed = 0.003; // How fast the wave moves
  const lineSpread = 10; // Vertical spacing between lines
  const animationDuration = 2; // Duration of each wave cycle for a line
  const color1 = '#FF4136'; // Red
  const color2 = '#0074D9'; // Blue
  const color3 = '#B10DC9'; // Purple

  useEffect(() => {
    if (!svgRef.current) return;

    const svg = svgRef.current;
    const { width, height } = svg.getBoundingClientRect();

    // Create lines if they don't exist
    if (svg.children.length === 0) {
      for (let i = 0; i < numLines; i++) {
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('stroke-width', '2');
        path.setAttribute('fill', 'none');
        svg.appendChild(path);
      }
    }

    const paths = Array.from(svg.querySelectorAll('path'));

    // GSAP Timeline
    const tl = gsap.timeline({ repeat: -1, yoyo: false });

    paths.forEach((path, i) => {
      // Initial vertical position for each line
      const initialY = height / 2 - (numLines / 2) * lineSpread + i * lineSpread;

      // Function to generate the path 'd' attribute for a given time offset
      const generatePathD = (timeOffset: number): string => {
        let d = `M 0 ${initialY}`;
        for (let x = 0; x <= width; x += 10) {
          // Main wave
          const y1 = initialY + amplitude * Math.sin(x * frequency + timeOffset);
          // Secondary, smaller, faster wave for more complex movement
          const y2 = amplitude * 0.3 * Math.sin(x * frequency * 2.5 + timeOffset * 2);
          // Third, wider, slower wave for overall undulation
          const y3 = amplitude * 0.5 * Math.sin(x * frequency * 0.5 + timeOffset * 0.5);
          d += ` L ${x} ${y1 + y2 + y3}`;
        }
        return d;
      };

      // Animate the 'd' attribute and stroke color
      // We use a proxy object to animate a 'time' value, then update the path in onUpdate
      const timeProxy = { val: 0 };
      tl.to(
        timeProxy,
        {
          val: Math.PI * 2, // One full sine wave cycle
          duration: animationDuration,
          ease: 'none',
          onUpdate: () => {
            path.setAttribute('d', generatePathD(timeProxy.val));
          },
          // Stagger the start of each line's animation
          delay: i * 0.05,
        },
        0 // All animations start at the same point in the timeline but with delays
      );

      // Animate stroke color
      // The color animation will cycle through color1 -> color2 -> color3 -> color1
      tl.to(path, {
        attr: { stroke: color2 },
        duration: animationDuration / 2,
        ease: 'power1.inOut',
        delay: i * 0.05
      }, 0);
      tl.to(path, {
        attr: { stroke: color3 },
        duration: animationDuration / 2,
        ease: 'power1.inOut',
        delay: i * 0.05
      }, animationDuration / 2);
       tl.to(path, {
        attr: { stroke: color1 },
        duration: animationDuration / 2, // Complete the cycle back to color1
        ease: 'power1.inOut',
        delay: i * 0.05
      }, animationDuration);


      // Set initial path and color
      path.setAttribute('d', generatePathD(0));
      path.setAttribute('stroke', color1);
    });


    // Ensure the SVG is responsive and redraws on resize
    const resizeObserver = new ResizeObserver(() => {
        // Re-calculate width/height and potentially re-initialize animation
        // For simplicity, we'll just restart the timeline here.
        // A more robust solution might involve recalculating path parameters.
        if (svgRef.current) {
            const newWidth = svgRef.current.clientWidth;
            const newHeight = svgRef.current.clientHeight;
            // Update any width/height dependent variables if necessary
            // For this example, the generatePathD function uses the current width.
            tl.restart();
        }
    });

    resizeObserver.observe(svg);


    return () => {
      tl.kill(); // Kill the timeline on component unmount
      paths.forEach(p => p.remove()); // Clean up paths
      resizeObserver.unobserve(svg);
    };
  }, []); // Empty dependency array ensures this runs once on mount

  return (
    <div className="flex items-center justify-center p-4">
      <svg
        ref={svgRef}
        className="w-full"
        preserveAspectRatio="xMidYMid meet"
        viewBox="0 0 500 100"
      >
        {/* Paths will be generated by useEffect */}
      </svg>
    </div>
  );
};

export default FlowingLinesAnimation;
